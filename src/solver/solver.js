// 6. import the javascript file that was generated by running `build.sh`
// The default import is a function which creates an instance of the module when called
// Call it to and keep the result in the `instance`

// 6. The `instance` contains a method called `cwrap`.
// Use it to create a wrapped version of the "move" function.

export async function init(site) {
  await new Promise(resolve => setTimeout(resolve, 1000));
  const buildings = site.getBuildings();
  var nDataBytes = buildings.length * buildings.BYTES_PER_ELEMENT;

  let instance;

  // Allocate memory inside the wasm module
  var dataPtr = instance._malloc(nDataBytes);
  // Create a view to the buffer on the Javascript side
  const data = new Float32Array(
    instance.HEAPF32.buffer,
    dataPtr,
    buildings.length
  );

  // Write the initial buildings into the module through the view
  data.set(buildings);

  // Javascript wrapper to run an iteration
  function iterate() {
    // 6. Call the wrapped move function
    // The first argument is a pointer to the memory location
    // The second argument is the number of buildings

    const hasConverged = isEqual(buildings, data);

    site.setBuildings(data);

    return hasConverged;
  }

  function cleanUp() {
    instance._free(dataPtr);
  }

  return { iterate };
}

function isEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}
